[
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Recommended Further Reading Materials",
    "section": "",
    "text": "Forta, B. (2015, July). Learning SQL [Video]. Pearson / O’Reilly. https://learning.oreilly.com/videos/learning-sql/9780134193700/9780134193700-LSQL_00_Introduction/\nHarris, J. K. (2019). Statistics with R: Solving problems using real-world data. SAGE Publications.\nJaggia, S., & Kelly, A. (2018). Business statistics: Communicating with numbers (3rd ed.). McGraw-Hill Education.\nJames, G., Witten, D., Hastie, T., & Tibshirani, R. (2013). An introduction to statistical learning: With applications in R. Springer. Springer Texts in Statistics.\nLutz, M. (2013). Learning Python (6th ed.). O’Reilly Media, Inc.\nZhao, A. (2021). SQL Pocket Guide (4th ed.). O’Reilly Media. Retrieved from https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch03.html.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Recommended Further Reading Materials</span>"
    ]
  },
  {
    "objectID": "mathnotation.html",
    "href": "mathnotation.html",
    "title": "Math Notation and Probability in R",
    "section": "",
    "text": "Math notation",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#math-notation",
    "href": "mathnotation.html#math-notation",
    "title": "Math Notation and Probability in R",
    "section": "",
    "text": "sigma, pi, functions, exponents, logic rules",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#creating-a-new-function-vs-using-a-built-in-function",
    "href": "mathnotation.html#creating-a-new-function-vs-using-a-built-in-function",
    "title": "Math Notation and Probability in R",
    "section": "Creating a new function vs using a built in function",
    "text": "Creating a new function vs using a built in function\n\nFunction_name: The name you assign to your function (e.g., my_sum)\n&lt;- Assignment operator: stores the function under the name\nfunction(): Declares that you’re defining a function\narguments: Inputs the function expects (e.g., x, y)\n{} The body: code that runs when the function is called\nreturn(): Specifies the value that gets returned (can also omit this in simple cases)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#sample-variance",
    "href": "mathnotation.html#sample-variance",
    "title": "Math Notation and Probability in R",
    "section": "Sample Variance",
    "text": "Sample Variance\n\\[\ns^2 = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})^2}{n - 1}\n\\]\n\nMeasures data spread.\nBasis for standard deviation.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#weighted-average",
    "href": "mathnotation.html#weighted-average",
    "title": "Math Notation and Probability in R",
    "section": "Weighted Average",
    "text": "Weighted Average\n\\[\n\\bar{x}_w = \\frac{\\sum_{i=1}^n w_i x_i}{\\sum_{i=1}^n w_i}\n\\]\n\nValues weighted by importance (e.g., confidence or revenue).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#dot-product-vectors",
    "href": "mathnotation.html#dot-product-vectors",
    "title": "Math Notation and Probability in R",
    "section": "Dot Product (Vectors)",
    "text": "Dot Product (Vectors)\n\\(x \\cdot w = \\sum_{i=1}^n x_i w_i\\)\n\nCore in machine learning models and matrix operations.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#sum-of-squared-errors-sse",
    "href": "mathnotation.html#sum-of-squared-errors-sse",
    "title": "Math Notation and Probability in R",
    "section": "Sum of Squared Errors (SSE)",
    "text": "Sum of Squared Errors (SSE)\n\\[\\text{SSE} = \\sum_{i=1}^n (y_i - \\hat{y}_i)^2\\]\n\nUsed in regression model evaluation\n\n\nx &lt;- c(2, 4, 6, 8, 9)\ny &lt;- c(1, 3, 4, 10, 8)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#covariance",
    "href": "mathnotation.html#covariance",
    "title": "Math Notation and Probability in R",
    "section": "Covariance",
    "text": "Covariance\n\\[ \\text{Cov}(X, Y) = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})(y_i - \\bar{y})}{n - 1}\\]\n\\[\nr = \\frac{\\text{Cov}(X, Y)}{\\sigma_X \\sigma_Y}\n\\]\n\nMeasures linear relationship between two variables\nCov(X, Y) is the covariance between variables ( X ) and ( Y ).\n( _X ) and ( _Y ) are the standard deviations of ( X ) and ( Y ), respectively.\nr ranges from −1 (perfect negative) to +1 (perfect positive).\nDescribes both strength and direction of a linear relationship.\nUnitless — unaffected by changes in scale or units.\n\n\nx &lt;- c(2, 4, 6, 8, 9)\ny &lt;- c(1, 3, 4, 10, 8)\n\nmean_x &lt;- mean(x)\nmean_y &lt;- mean(y)\n\ncov_xy &lt;- sum((x-mean_x)*(y-mean(y)))/(5-1); cov_xy\n\n[1] 9.8\n\ncor_xy &lt;- cov_xy/(sd(x)*sd(y)); cor_xy\n\n[1] 0.9246106",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#mean-absolute-error-mae",
    "href": "mathnotation.html#mean-absolute-error-mae",
    "title": "Math Notation and Probability in R",
    "section": "Mean Absolute Error (MAE)",
    "text": "Mean Absolute Error (MAE)\n\\(\\text{MAE} = \\frac{1}{n} \\sum_{i=1}^n | y_i - \\hat{y}_i|\\)\n\nMeasures average size of prediction error.\nLess sensitive to outliers than SSE.\n\nGiven:\n\nActual values: 3, 5, 2, 7\n\nPredicted values: 2, 6, 2.5, 8\n\nAbsolute Errors: \\[|3 - 2| = 1,\\quad |5 - 6| = 1,\\quad |2 - 2.5| = 0.5,\\quad |7 - 8| = 1\\]\nMAE Calculation:\n\\[\n\\text{MAE} = \\frac{1 + 1 + 0.5 + 1}{4} = \\frac{3.5}{4} = 0.875\n\\]",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#mean-squared-error-mse",
    "href": "mathnotation.html#mean-squared-error-mse",
    "title": "Math Notation and Probability in R",
    "section": "Mean Squared Error (MSE)",
    "text": "Mean Squared Error (MSE)\n\\(\\text{MSE} = \\frac{1}{n} \\sum_{i=1}^n (y_i - \\hat{y}_i)^2\\)\n\nMeasures the average of the squared differences between actual and predicted values.\n\nA common metric to evaluate the accuracy of regression models.\n\nSensitive to large errors due to squaring.\n\nSquared Errors:\n\\[\n(3 - 2)^2 = 1,\\quad (5 - 6)^2 = 1,\\quad (2 - 2.5)^2 = 0.25,\\quad (7 - 8)^2 = 1\n\\]\nMSE Calculation:\n\\[\n\\text{MSE} = \\frac{1 + 1 + 0.25 + 1}{4} = \\frac{3.25}{4} = 0.8125\n\\]",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#log-likelihood-logistic-regression",
    "href": "mathnotation.html#log-likelihood-logistic-regression",
    "title": "Math Notation and Probability in R",
    "section": "Log-Likelihood (Logistic Regression)",
    "text": "Log-Likelihood (Logistic Regression)\n\\(\\ell(\\beta) = \\sum_{i=1}^n [ y_i \\log(p_i) + (1 - y_i) \\log(1 - p_i)]\\)\n\nQuantifies how likely predicted probabilities match observed outcomes\n\nMaximized to estimate model parameters \\(\\beta\\).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#k-means-clustering-objective",
    "href": "mathnotation.html#k-means-clustering-objective",
    "title": "Math Notation and Probability in R",
    "section": "K-Means Clustering Objective",
    "text": "K-Means Clustering Objective\n\\(J = \\sum_{i=1}^k \\sum_{x \\in C_i} \\| x - \\mu_i \\|^2\\)\n\nK-Means Clustering is an unsupervised machine learning algorithm used to group data points into k clusters based on similarity, essentially measuring the within-cluster variance.\n\nEach data point is assigned to the cluster with the nearest centroid (mean of the cluster).\nThe algorithm aims to minimize the total within-cluster variance — that is, the distance between points and their cluster centers.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#euclidean-distance",
    "href": "mathnotation.html#euclidean-distance",
    "title": "Math Notation and Probability in R",
    "section": "Euclidean Distance",
    "text": "Euclidean Distance\n\\[\nd_{\\text{euclidean}}(x, y) = \\sqrt{\\sum_{i=1}^n (x_i - y_i)^2}\n\\]\n\nMeasures the straight-line (as-the-crow-flies) distance between two points in n-dimensional space.\nCommonly used in clustering, nearest neighbor models, and geometry.\nSensitive to scale — variables should often be standardized.\nExample: \\(d = \\sqrt{(x_1 - y_1)^2 + (x_2 - y_2)^2}\\)\nEuclidean: \\(\\sqrt{(5 - 2)^2 + (5 - 1)^2} = \\sqrt{9 + 16} = \\sqrt{25} = 5\\)\n\n\n\n\nEuclidean Distance",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#manhattan-distance",
    "href": "mathnotation.html#manhattan-distance",
    "title": "Math Notation and Probability in R",
    "section": "Manhattan Distance",
    "text": "Manhattan Distance\n\\[\nd_{\\text{manhattan}}(x, y) = \\sum_{i=1}^n |x_i - y_i|\n\\]\n\nMeasures distance along axes only — like navigating a grid of city streets.\nMore robust to outliers than Euclidean distance.\nUsed in clustering, especially when features are not continuous or are sparse (e.g., in NLP or recommender systems).\nExample: \\(d = |x_1 - y_1| + |x_2 - y_2|\\)\nManhattan: \\(|5 - 2| + |5 - 1| = 3 + 4 = 7\\)\n\n\n\n\nManhattan Distance",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#function-basics",
    "href": "mathnotation.html#function-basics",
    "title": "Math Notation and Probability in R",
    "section": "Function Basics",
    "text": "Function Basics\n\nFunction Properties\n\nInjective: No two inputs map to the same output\nSurjective: Every element in the codomain is mapped to by some input\nBijective: Both injective and surjective\n\nExample: \\(f(x) = 2x\\) on domain \\(\\mathbb{Z}\\) is injective but not surjective on \\(\\mathbb{Z}\\)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#odds-distance-measures",
    "href": "mathnotation.html#odds-distance-measures",
    "title": "Math Notation and Probability in R",
    "section": "Odds, distance measures",
    "text": "Odds, distance measures",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "mathnotation.html#implement-probability-calculations",
    "href": "mathnotation.html#implement-probability-calculations",
    "title": "Math Notation and Probability in R",
    "section": "Implement probability calculations",
    "text": "Implement probability calculations",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Math Notation and Probability in R</span>"
    ]
  },
  {
    "objectID": "pythonsetup.html",
    "href": "pythonsetup.html",
    "title": "Python and Environment Set up",
    "section": "",
    "text": "Python Installation and IDEs (VS Code)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python and Environment Set up</span>"
    ]
  },
  {
    "objectID": "pythonsetup.html#setting-up-virtual-environments-conda",
    "href": "pythonsetup.html#setting-up-virtual-environments-conda",
    "title": "Python and Environment Set up",
    "section": "Setting up virtual environments (conda)",
    "text": "Setting up virtual environments (conda)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python and Environment Set up</span>"
    ]
  },
  {
    "objectID": "pythonsetup.html#python-basics-variables-operators-functions",
    "href": "pythonsetup.html#python-basics-variables-operators-functions",
    "title": "Python and Environment Set up",
    "section": "Python basics (variables, operators, functions)",
    "text": "Python basics (variables, operators, functions)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python and Environment Set up</span>"
    ]
  },
  {
    "objectID": "advmath.html",
    "href": "advmath.html",
    "title": "Calculus and Linear Algebra",
    "section": "",
    "text": "What Is a Derivative?",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Calculus and Linear Algebra</span>"
    ]
  },
  {
    "objectID": "advmath.html#a-simple-function-and-its-slope",
    "href": "advmath.html#a-simple-function-and-its-slope",
    "title": "Calculus and Linear Algebra",
    "section": "A Simple Function and Its Slope",
    "text": "A Simple Function and Its Slope\n\nLet’s start with: \\[\nf(x) = x^2\n\\]\nWe can plot it in R and look at the slope at a few points.\n\n\nlibrary(tidyverse)\n\n# Define the function and its derivative\nf &lt;- function(x) x^2\ndf &lt;- data.frame(x = seq(-5, 5, by = 0.1))\ndf$fx &lt;- f(df$x) #applying function x^2\n\n# Key points\nkey_points &lt;- data.frame(x = c(-2, 0, 2), fx = f(c(-2, 0, 2)))\n\n# Plot using ggplot2\nggplot(df, aes(x = x, y = fx)) +\n  geom_line(color = \"blue\") +\n  geom_vline(xintercept = c(-2, 0, 2), linetype = \"dashed\", color = \"gray\") +\n  geom_point(data = key_points, aes(x = x, y = fx), color = \"red\") +\n  labs(y = \"f(x)\", title = \"Plot of f(x) = x^2\") +\n  theme_minimal()",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Calculus and Linear Algebra</span>"
    ]
  },
  {
    "objectID": "advmath.html#sine-and-its-derivative",
    "href": "advmath.html#sine-and-its-derivative",
    "title": "Calculus and Linear Algebra",
    "section": "Sine and Its Derivative",
    "text": "Sine and Its Derivative\n\nWe explore the function ( f(x) = (x) ) and its derivative ( f’(x) = (x) ). The derivative of a function tells us the slope of the tangent line at any point. For trigonometric functions like sine, the derivative reveals how the rate of change behaves across the domain.\n\n[ (x) = (x) ]\n\nWe’ll visualize both ( (x) ) and ( (x) ) to see how the function and its rate of change are related.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Calculus and Linear Algebra</span>"
    ]
  },
  {
    "objectID": "advmath.html#derivative-rules",
    "href": "advmath.html#derivative-rules",
    "title": "Calculus and Linear Algebra",
    "section": "Derivative Rules",
    "text": "Derivative Rules\n\\[\n\\begin{array}{|l|l|l|}\n\\hline\n\\textbf{Rule} & \\textbf{Function} & \\textbf{Derivative} \\\\\n\\hline\n\\text{Multiplication by Constant} & c f & c f' \\\\\n\\text{Power Rule} & x^n & n x^{n-1} \\\\\n\\text{Sum Rule} & f + g & f' + g' \\\\\n\\text{Difference Rule} & f - g & f' - g' \\\\\n\\text{Product Rule} & fg & f g' + f' g \\\\\n\\text{Quotient Rule} & \\frac{f}{g} & \\frac{f' g - g' f}{g^2} \\\\\n\\text{Reciprocal Rule} & \\frac{1}{f} & -\\frac{f'}{f^2} \\\\\n\\hline\n\\end{array}\n\\]",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Calculus and Linear Algebra</span>"
    ]
  },
  {
    "objectID": "advmath.html#chain-rule-variants",
    "href": "advmath.html#chain-rule-variants",
    "title": "Calculus and Linear Algebra",
    "section": "Chain Rule Variants",
    "text": "Chain Rule Variants",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Calculus and Linear Algebra</span>"
    ]
  },
  {
    "objectID": "advmath.html#from-slopes-to-gradients",
    "href": "advmath.html#from-slopes-to-gradients",
    "title": "Calculus and Linear Algebra",
    "section": "From Slopes to Gradients",
    "text": "From Slopes to Gradients\n\nIn one variable, the slope of a function tells us how steeply the function increases or decreases: [ = ]\nFor example, if ( f(x) = x^2 ), the slope at any point is: [ f’(x) = 2x ]\nThis slope tells us the direction and steepness of the curve at a specific point.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Calculus and Linear Algebra</span>"
    ]
  },
  {
    "objectID": "advmath.html#what-is-a-gradient",
    "href": "advmath.html#what-is-a-gradient",
    "title": "Calculus and Linear Algebra",
    "section": "What Is a Gradient?",
    "text": "What Is a Gradient?\n\nIn multiple dimensions, we generalize the idea of slope to the gradient.\nThe gradient is a vector of partial derivatives:\n\n[ f(x, y) = ]\n\nIt points in the direction of steepest ascent of a function.\nThe gradient gives us the rate of change in each direction.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Calculus and Linear Algebra</span>"
    ]
  },
  {
    "objectID": "advmath.html#visualizing-gradient-with-a-3d-surface",
    "href": "advmath.html#visualizing-gradient-with-a-3d-surface",
    "title": "Calculus and Linear Algebra",
    "section": "Visualizing Gradient with a 3D Surface",
    "text": "Visualizing Gradient with a 3D Surface\nLet’s take a simple surface:\n[ f(x, y) = x^2 + y^2 ]\n\nThe gradient is:\n\n[ f(x, y) = [2x, 2y] ]\n\nIt always points away from the origin, where the minimum is.\nThis is important because many optimization methods (like gradient descent) use the gradient to navigate the surface.\n\n\nlibrary(ggplot2)\nlibrary(dplyr)\n\ndf &lt;- expand.grid(x = seq(-2, 2, length.out = 20),\n                  y = seq(-2, 2, length.out = 20)) %&gt;%\n  mutate(z = x^2 + y^2,\n         dx = 2 * x,\n         dy = 2 * y)\n\nggplot(df, aes(x, y)) +\n  geom_contour(aes(z = z), bins = 15, color = \"gray\") +\n  geom_segment(aes(xend = x + dx * 0.1, yend = y + dy * 0.1), \n               arrow = arrow(length = unit(0.1, \"inches\")), \n               color = \"blue\") +\n  labs(title = \"Gradient Vectors on f(x, y) = x² + y²\",\n       x = \"x\", y = \"y\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\nGradients are used to — to find minimum cost, maximum profit, or best-fit models.\n\nIn machine learning, we use an algorithm called gradient descent:\nMove in the opposite direction of the gradient to reduce error.\nRepeat until the algorithm converges on a minimum.\n\n[ {} = {} - f() ]\n\\(\\alpha\\) is the learning rate, and ( f() ) is the gradient.\nThis powers tools like , , and neural networks.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Calculus and Linear Algebra</span>"
    ]
  },
  {
    "objectID": "advmath.html#matrix-multiplication-example-1",
    "href": "advmath.html#matrix-multiplication-example-1",
    "title": "Calculus and Linear Algebra",
    "section": "Matrix Multiplication Example",
    "text": "Matrix Multiplication Example\nWe want to multiply two (2 ) matrices:\n[\n\\[\\begin{bmatrix}\n0.6 & -0.7 \\\\\n-0.2 & 0.4\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n4 & 7 \\\\\n2 & 6\n\\end{bmatrix}\\]\n]\nUsing matrix multiplication rules:\n[\n\\[\\begin{bmatrix}\n(0.6)(4) + (-0.7)(2) & (0.6)(7) + (-0.7)(6) \\\\\n(-0.2)(4) + (0.4)(2) & (-0.2)(7) + (0.4)(6)\n\\end{bmatrix}\\]\n=\n\\[\\begin{bmatrix}\n1.0 & 0.0 \\\\\n0.0 & 1.0\n\\end{bmatrix}\\]\n]\nThis is the identity matrix ( I_2 ), so:\n[\n\\[\\begin{bmatrix}\n0.6 & -0.7 \\\\\n-0.2 & 0.4\n\\end{bmatrix}\n\\text{ is the inverse of }\n\\begin{bmatrix}\n4 & 7 \\\\\n2 & 6\n\\end{bmatrix}\\]\n]",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Calculus and Linear Algebra</span>"
    ]
  },
  {
    "objectID": "advmath.html#u-contains-the-left-singular-vectors",
    "href": "advmath.html#u-contains-the-left-singular-vectors",
    "title": "Calculus and Linear Algebra",
    "section": "U contains the left singular vectors",
    "text": "U contains the left singular vectors\n\nThese are the eigenvectors of \\(AA^T\\). They represent directions in the row space of \\(A\\). Each column of \\(U\\) corresponds to a principal direction in the data.\nInterpreted as: how the original rows (observations) are projected into orthogonal directions. ::: {.cell}\n\nU &lt;- svd_result$u; U\n\n           [,1]       [,2]\n[1,] -0.6556797  0.7350057\n[2,] -0.3673531 -0.5104646\n[3,] -0.6596482 -0.4463100\n\n::: ## Sigma contains the singular values * These are the square roots of the eigenvalues of both \\(AA^T\\) and \\(A^TA\\), sorted from largest to smallest: + They tell you how much variance or information is captured along each corresponding singular vector direction. + Larger singular values = more important directions. * Interpreted as: the strength (or importance) of each latent feature in the data. ::: {.cell}\nSigma &lt;- diag(svd_result$d); Sigma\n\n         [,1]    [,2]\n[1,] 9.673049 0.00000\n[2,] 0.000000 1.19671\n\n::: ## V contains the right singular vectors * These are the eigenvectors of \\(A^TA\\) and represent directions in the column space of \\(A\\). Each column of \\(V\\) tells you how the original features (columns of \\(A\\)) align with the principal components. $ Interpreted as: how the original features are weighted to form the components. ::: {.cell}\nV &lt;- svd_result$v; V\n\n           [,1]       [,2]\n[1,] -0.7260399 -0.6876526\n[2,] -0.6876526  0.7260399\n\n:::\n\nWe classify the matrix as rank 2 because of the number of non-zero singular values in its SVD (under Sigma).Since the matrix has rank 2, its rows are linearly independent (but not full-rank in a 3-dimensional space).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Calculus and Linear Algebra</span>"
    ]
  },
  {
    "objectID": "datastructures.html",
    "href": "datastructures.html",
    "title": "Data Structures",
    "section": "",
    "text": "Lists",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "datastructures.html#tuples",
    "href": "datastructures.html#tuples",
    "title": "Data Structures",
    "section": "Tuples",
    "text": "Tuples",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "datastructures.html#dictionaries",
    "href": "datastructures.html#dictionaries",
    "title": "Data Structures",
    "section": "Dictionaries",
    "text": "Dictionaries",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "datastructures.html#sets",
    "href": "datastructures.html#sets",
    "title": "Data Structures",
    "section": "Sets",
    "text": "Sets",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "datastructures.html#list-comprehension",
    "href": "datastructures.html#list-comprehension",
    "title": "Data Structures",
    "section": "List Comprehension",
    "text": "List Comprehension\n\nIntroduction: What Is a List Comprehension?\nA list comprehension is a concise, elegant way to create new lists in Python — often replacing multi-line loops with a single readable line. Think of it as a powerful shorthand that lets you transform, filter, and process data with minimal code.\nLet’s start with the traditional approach\n\n\n[1, 4, 9, 16, 25]\n\n\nThis works fine, but it’s a bit long for such a simple task. We need three separate steps: initialize an empty list, loop through values, and append results one by one.\nThat’s why we have List Comprehensions in Python. Python lets you compress those three steps into one clean line using list comprehension, making your code more Pythonic and easier to read.\nThe general syntax is:\n[ expression for item in iterable]\nWhere:\n\nexpression → what you want to do with each item (like squaring a number or making text uppercase)\nfor item in iterable → the loop through your data (like numbers, strings, or lists)\nThe entire comprehension is wrapped in square brackets [] which tells Python to create a new list\n\nLet’s rewrite our earlier example:\n\n\n[1, 4, 9, 16, 25]\n\n\nSame output, shorter code and once you get used to it, it is much more readable! Notice how we eliminated the need to initialize an empty list and manually append values.\nList comprehensions work on any iterable, not just numbers. Let’s try it with strings.\n\n\n['APPLE', 'BANANA', 'KIWI', 'GRAPE']\n\n\nHere this code is saying: “Take each fruit in fruits, make it uppercase, and collect the results in a new list.” The .upper() method is applied to every string automatically as we loop through.\n\n\nExercises\nExercise 1: Word Lengths\nCreate a new list called lengths that contains the length of each word in the list.\nEnter Code here\n\n\n[6, 8, 4, 8, 7]\n\n\nExercise 2: Filtering with Conditions\nCreate a list called long_words that includes only words longer than 6 characters.\nEnter Code here\n\n\n['bootcamp', 'listcomp', 'concise']\n\n\nExercise 3: Filtering and Transforming Numbers\nFrom the numbers 1–20, make a new list called divisible_by_3_doubled that:\n\nOnly includes numbers divisible by 3\nDoubles each of those numbers\n\nEnter Code here\n\n\n[6, 12, 18, 24, 30, 36]\n\n\n\n\nAdding Conditions: if, else and elif\nList comprehensions are not just for simple loops. You can also add conditional logic to decide what gets included or what value is produced. This is where list comprehensions become truly powerful, allowing you to filter data and transform values based on specific criteria.\n\nUsing if as a Filter\nYou can use if at the end of a comprehension to only include items that meet a condition. This acts as a filter, letting only certain items “pass through” into your new list.\n\n\n[2, 4, 6, 8, 10]\n\n\nStep-by-step:\n\nLoop through each num in numbers (1 through 10).\nCheck if num % 2 == 0 → only even numbers pass the filter.\nThe expression num is added to the new list if the condition is True.\nOdd numbers (1, 3, 5, 7, 9) are skipped entirely.\n\nOutput: [2, 4, 6, 8, 10]\nKey Point: When if appears at the END of the comprehension, it’s a filter. Items that don’t meet the condition are excluded from the result.\n\n\nUsing if–else in Expressions\nSometimes you want all items included, but with different values depending on a condition. Here, the if–else is inside the expression at the beginning, not at the end. This means every item will appear in the new list, but their values will be transformed differently based on the condition.\n\n\n['odd', 'even', 'odd', 'even', 'odd']\n\n\nStep-by-step:\n\nLoop through each num (1, 2, 3, 4, 5).\nCheck the condition: num % 2 == 0\n\nIf True → add the string \"even\"\nIf False → add the string \"odd\"\n\nEvery number produces a result — nothing is filtered out.\n\nOutput: ['odd', 'even', 'odd', 'even', 'odd']\nKey Point: When if–else appears at the BEGINNING (in the expression), it transforms values rather than filtering. Every item is included, just with different values.\n\n\nChaining Conditions (Like elif)\nPython does not have a direct elif in a comprehension, but you can chain multiple if–else expressions to create multi-way branching logic. The conditions are evaluated in order from left to right, and the first true condition determines the output.\nExample: Categorizing Student Scores\n\n\n['Excellent', 'Good', 'Needs Improvement', 'Good', 'Needs Improvement', 'Needs Improvement']\n\n\nStep-by-step:\n\nLoop through each s in scores.\nCheck first condition s &gt;= 90:\n\nIf True → assign \"Excellent\" and stop checking\nIf False → move to next condition\n\nCheck second condition s &gt;= 70:\n\nIf True → assign \"Good\" and stop checking\nIf False → assign the default \"Needs Improvement\"\n\nThis creates a cascading decision tree for each score.\n\nOutput: ['Excellent', 'Good', 'Needs Improvement', 'Good', 'Needs Improvement', 'Good']\nExample: Temperature Categories\n\n\n['Hot', 'Warm', 'Warm', 'Cold', 'Hot', 'Cold', 'Warm']\n\n\nStep-by-step:\n\nLoop through each t in temps.\nCheck t &gt;= 30:\n\nIf True → assign \"Hot\" (like 35 and 30)\n\nElse check t &gt;= 20:\n\nIf True → assign \"Warm\" (like 28, 22, 25)\n\nElse assign \"Cold\" (like 18 and 10)\nEach temperature gets exactly one category.\n\nOutput: ['Hot', 'Warm', 'Warm', 'Cold', 'Hot', 'Cold', 'Warm']\nTip: You can chain as many if–else conditions as needed to mimic elif logic in a single comprehension. Just remember that they’re evaluated left to right, and the first matching condition wins.\n\n\nFiltering + Conditional Output\nYou can also combine filtering (if at the end) with conditional expressions inside the comprehension. This gives you maximum flexibility: transform values differently based on one condition, then filter the results based on another condition.\n\n\n[1, 4, 3, 8, 5, 12, 7, 16, 9]\n\n\nStep-by-step:\n\nLoop through numbers 1–15.\nFilter (at the end): only include numbers &lt; 10 (so 1-9 are considered).\nExpression (at the beginning):\n\nIf even → double it (2→4, 4→8, 6→12, 8→16)\nIf odd → keep as-is (1→1, 3→3, 5→5, 7→7, 9→9)\n\nNumbers 10-15 are excluded before transformation even happens.\n\nOutput: [1, 4, 3, 8, 5, 12, 7, 16, 9]\nOrder of Operations: Python first filters the items (the if at the end), then applies the transformation expression to each item that passed the filter.\n\n\n\nNested Comprehensions (2D Lists)\nList comprehensions can also loop over multiple levels of data, like lists of lists (2D lists or matrices). This is called a nested comprehension. While it might look complex at first, it follows the same left-to-right reading pattern as nested for-loops.\n\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nExplanation and step-by-step overview:\n\nFirst loop: for row in matrix — Loop through each row in matrix (each row is a list).\nSecond loop: for num in row — Then loop through each num in that row.\nExpression: num — Collect each num into a new flat list.\nReading order: Read left to right, just like you would write nested for-loops.\n\nThis is equivalent to the following traditional nested loop, but much shorter and cleaner:\n\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9]\nVisualization: The 3×3 matrix is “flattened” into a single list of 9 numbers, preserving the order from left to right, top to bottom.\n\n\nQuick Recap: List Comprehensions\n\n\n\n\n\n\n\n\n\nConcept\nSyntax\nDescription\nExample\n\n\n\n\nBasic\n[x for x in iterable]\nLoop through values and collect them\n[n for n in range(5)]\n\n\nFilter\n[x for x in iterable if condition]\nInclude only items meeting condition (filter at the end)\n[n for n in range(10) if n%2==0]\n\n\nConditional\n[expr_if_true if cond else expr_if_false for x in iterable]\nChange output based on condition (all items included)\n[\"even\" if n%2==0 else \"odd\" for n in range(6)]\n\n\nChained / elif\n[expr1 if cond1 else expr2 if cond2 else expr3 for x in iterable]\nMultiple condition branches (cascading logic)\n[\"High\" if s&gt;=90 else \"Medium\" if s&gt;=70 else \"Low\" for s in scores]\n\n\nNested\n[item for sublist in list_of_lists for item in sublist]\nFlatten or loop through nested lists (read left to right)\n[num for row in matrix for num in row]\n\n\n\n\n\nKey Ideas\n\nPerformance: List comprehensions are faster than traditional loops because they’re optimized at the interpreter level.\nReadability: Keep comprehensions readable — if it gets too complex, break it into multiple lines or use a traditional loop.\nUse cases: Use comprehensions when transforming or filtering data; use traditional loops for more complex logic with multiple operations.\nMemory: For very large datasets, consider using generator expressions (x for x in iterable) instead of list comprehensions to save memory.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "datastructures.html#strings-and-string-manipulation",
    "href": "datastructures.html#strings-and-string-manipulation",
    "title": "Data Structures",
    "section": "Strings and String Manipulation",
    "text": "Strings and String Manipulation",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Files, Functions, and Folders",
    "section": "",
    "text": "Reading/writing files (CSV, TXT)",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Files, Functions, and Folders</span>"
    ]
  },
  {
    "objectID": "functions.html#navigating-directories",
    "href": "functions.html#navigating-directories",
    "title": "Files, Functions, and Folders",
    "section": "Navigating directories",
    "text": "Navigating directories",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Files, Functions, and Folders</span>"
    ]
  },
  {
    "objectID": "functions.html#functions-and-scope-making-own-functions",
    "href": "functions.html#functions-and-scope-making-own-functions",
    "title": "Files, Functions, and Folders",
    "section": "Functions and scope (Making own functions)",
    "text": "Functions and scope (Making own functions)",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Files, Functions, and Folders</span>"
    ]
  },
  {
    "objectID": "functions.html#debugging-techniques",
    "href": "functions.html#debugging-techniques",
    "title": "Files, Functions, and Folders",
    "section": "Debugging techniques",
    "text": "Debugging techniques",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Files, Functions, and Folders</span>"
    ]
  },
  {
    "objectID": "numpypandas.html",
    "href": "numpypandas.html",
    "title": "If Statements and While Loops",
    "section": "",
    "text": "If Statements\nWelcome to your first lesson in Python control flow.\nIn programming and especially in analytics it’s not enough to simply store or calculate data. We also need to make decisions (“if this, then that”) and repeat actions (“keep doing this until done”).\nFor example:\nIn Python, two of the most common tools for this are:",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>If Statements and While Loops</span>"
    ]
  },
  {
    "objectID": "numpypandas.html#if-statements",
    "href": "numpypandas.html#if-statements",
    "title": "If Statements and While Loops",
    "section": "",
    "text": "Note\n\n\n\nReferences from Lutz, M. (2013). Learning Python (6th ed.). O’Reilly Media, Inc.\n\n\n\n\n\n\nA financial model might check if profit &gt; target, then apply a bonus.\nA data-cleaning script might keep looping while there are missing values.\n\n\n\nif statements → for decision making\nwhile loops → for repetition and automation\n\n\nLogical Conditions\nBefore we jump into Python syntax, let’s talk conceptually.\nA condition is something that can be either True or False.\nExamples of conditions in everyday life:\n\nIs it raining? → True or False\nIs my grade above 90? → True or False\nIs the customer balance less than zero? → True or False\n\nIn Python, we can write conditions using comparison operators:\n\n\n\nSymbol\nMeaning\nExample\nResult\n\n\n\n\n==\nequal to\n5==5\nTrue\n\n\n!=\nnot equal to\n5!=3\nTrue\n\n\n&gt;\ngreater than\n7&gt;3\nTrue\n\n\n&lt;\nless than\n2&lt;10\nTrue\n\n\n&gt;=\ngreater or equal\n5&gt;=5\nTrue\n\n\n&lt;=\nless or equal\n4&lt;=3\nFalse\n\n\n\n\n\nTrue\n\n\nFalse\n\n\nFalse\n\n\nThese Boolean results are what drive decision-making in code.\n\n\nBasic Syntax\nIn simple terms, the Python if statement selects actions to perform. Along with its if expression counterpart, it’s the primary selection tool in Python and represents much of the logic a Python program possesses. It’s also our first compound statement. Like all such statements, the if statement may contain other statements, including other ifs. In fact, Python lets you combine statements in a program both sequentially (so that they execute one after another), and in an arbitrarily nested fashion (so that they execute only under certain conditions, such as selections and loops).\nAn if statement tells Python: “Only run this block of code if a certain condition is true.”\nThink of it like a business rule: If revenue is above target, then give a performance bonus.\nSyntax:\n\n\nSimple Example\n\n\nBonus approved!\n\n\nBecause the condition revenue &gt; target is true, Python prints the message.\nTry changing revenue to a smaller number and re-run the code and see if it still prints the same thing.\n\n\nIf-Else\nWhat if we also want to say something when the condition is not true? That’s where else comes in.\n\n\nNeeds improvement.\n\n\nPython checks the if condition first. If it’s false, it runs the else block instead.\n\n\nMultiple Conditions\nWhen you have more than two possibilities, use elif (“else if”).\n\n\nGrade: B\n\n\nPython checks the conditions in order and runs the first one that’s true.\n\n\nCombining Conditions\nYou can combine multiple conditions using:\n\nand → both must be true\nor → at least one is true\nnot → reverses true/false\n\n\n\nEligible for credit card\n\n\n\n\nNested Statements\nYou can also put one if inside another for more complex logic.\n\n\nYou can enter.\n\n\nThis structure is common in data workflows — checking multiple business rules in sequence.\n\n\nPractice\nWrite your own example:\n\nAsk for a test score (input)\nPrint “Excellent” if 90+, “Good” if 80–89, otherwise “Needs Improvement”",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>If Statements and While Loops</span>"
    ]
  },
  {
    "objectID": "numpypandas.html#while-loops",
    "href": "numpypandas.html#while-loops",
    "title": "If Statements and While Loops",
    "section": "While Loops",
    "text": "While Loops",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>If Statements and While Loops</span>"
    ]
  },
  {
    "objectID": "numpypandas.html#loop-basics",
    "href": "numpypandas.html#loop-basics",
    "title": "If Statements and While Loops",
    "section": "Loop Basics",
    "text": "Loop Basics\nPython’s while statement is the most general iteration construct in the language. In simple terms, it repeatedly executes an associated block of statements as long as a test at the top keeps evaluating to a true value. It is called a “loop” because control keeps looping back to the start of the statement until the test becomes false. When the test does become false, control passes to the statement that follows the while block. The net effect is that the loop’s body is executed repeatedly while the test at the top is true. If the test is false to begin with, the body never runs and the while statement is skipped.\nBasically sometimes we need to repeat a task several times — or until a condition changes.\nExample in plain language: While there are still customers in line → keep serving.\nIn Python the syntax is:\nThe loop runs again and again as long as the condition is true.\n\n\nHello, world!\nHello, world!\nHello, world!\n\n\nThis prints three lines because:\n\nStart: count = 1\nEach loop: print, then add 1\nStop when count &lt;= 3 becomes false\n\n\nInfinite Loops\nIf the condition never becomes false, the loop never ends.\nAlways make sure something inside your loop changes the condition.\n\n\nLoop Control\nIn Python we can control loop flow manually.\nbreak: Jumps out of the closest enclosing loop (past the entire loop statement)\ncontinue: Jumps to the top of the closest enclosing loop (to the loop’s header line)\npass: Does nothing at all: it’s an empty statement placeholder\nLoop else block: Runs if and only if the loop is exited normally (i.e., without hitting a break)\nbreak and continue statements can appear anywhere inside the while (or per ahead, for) loop’s body, but they are usually coded further nested in an if test to take action in response to some condition.\nbreak → exit the loop early\n\n\n1\n2\n\n\ncontinue → skip this iteration\n\n\n1\n2\n4\n5\n\n\n\n\nWhile-Else\nA while loop can also have an else block that runs when the loop ends normally (without break).\n\n\nx = 3\nx = 2\nx = 1\nLoop finished!\n\n\n\n\nCombined Example\nWe can combine both ideas to make small, smart programs.\nExplanation:\n\nThe while loop keeps asking until the user guesses correctly.\nThe if inside checks how the guess compares to the secret number.\n\n\n\nSummary\n\n\n\nConcept\nPurpose\nExample\n\n\n\n\nif\nRun code when condition is true\nif x &gt; 5:\n\n\nelse\nRun code when condition is false\nelse:\n\n\nelif\nTest another condition\nelif x == 5:\n\n\nwhile\nRepeat while condition is true\nwhile x &lt; 10:\n\n\nbreak\nExit the loop early\nbreak\n\n\ncontinue\nSkip current iteration\ncontinue",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>If Statements and While Loops</span>"
    ]
  },
  {
    "objectID": "numpypandas.html#numpy",
    "href": "numpypandas.html#numpy",
    "title": "If Statements and While Loops",
    "section": "Numpy",
    "text": "Numpy",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>If Statements and While Loops</span>"
    ]
  },
  {
    "objectID": "numpypandas.html#pandas",
    "href": "numpypandas.html#pandas",
    "title": "If Statements and While Loops",
    "section": "Pandas",
    "text": "Pandas",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>If Statements and While Loops</span>"
    ]
  },
  {
    "objectID": "numpypandas.html#data-cleaning",
    "href": "numpypandas.html#data-cleaning",
    "title": "If Statements and While Loops",
    "section": "Data Cleaning",
    "text": "Data Cleaning",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>If Statements and While Loops</span>"
    ]
  },
  {
    "objectID": "sql.html",
    "href": "sql.html",
    "title": "Introduction to SQL in Python",
    "section": "",
    "text": "Installing MySQL\nBooks:",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to SQL in Python</span>"
    ]
  },
  {
    "objectID": "sql.html#sql-syntax-notes",
    "href": "sql.html#sql-syntax-notes",
    "title": "Introduction to SQL in Python",
    "section": "SQL syntax notes:",
    "text": "SQL syntax notes:\n\nSQL has a flexible and easy-to-read syntax.\n\nA semicolon (;) marks the end of a SQL statement, which is especially helpful when several statements appear in sequence.\nSQL keywords (such as SELECT, FROM, and WHERE) and the names of tables and columns are not case sensitive, so formatting is up to the user.\nSQL commands can also be written on a single line or spread across multiple lines for clarity.\n\nThese features make SQL straightforward to write, easy to interpret, and adaptable to many coding styles.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to SQL in Python</span>"
    ]
  },
  {
    "objectID": "sql.html#creating-a-database-in-sql",
    "href": "sql.html#creating-a-database-in-sql",
    "title": "Introduction to SQL in Python",
    "section": "Creating a Database in SQL:",
    "text": "Creating a Database in SQL:\nUse CREATE DATABASE to create a new database using SQL\nCREATE DATABASE DBName;\n\nCreating tables, columns, and keys in the database\n\nUSE specifies that database you will be using\nCREATE TABLE creates a table in your specified database\nnew column names are followed by the column data type\n\nUSE DBName;\nCREATE TABLE TName\n(Column1 data type NOT NULL, (if mandatory)\nColumn 2 data type, (if optional)\n…\nColumn data type NOT NULL, \nPRIMARY KEY (Column1),\nFOREIGN KEY (Column) references OtherTable (column));\n\n\nSQL data types:\n\nCHAR(n): fixed length n character string\nVARCHAR(n): variable length character string with a maximum size of n characters\nINT: integer\nNUMERIC(x,y): number with x digits, y of which are after the decimal point\nDATE: date values (year, month, day)\n\n\n\nAltering a Table\nUse ALTER TABLE to alter column in a table\n\nADD adds columns\nDROP drops columns\n\nALTER TABLE tablename ADD (Column data type)\nALTER TABLE tablename DROP (Column);\n\n\nInsert values into a table\nUse INSERT INTO tablename VALUES to insert data into the rows of a table\nINSERT INTO tablename VALUES (column1, column2, …);\nFor example, if we want to add a row into a table, students, with the columns StudentID, FirstName, LastName, DateOfEnrollment, Email:\nINSERT INTO students VALUES (1, ‘Maria’, ‘Gonzales’, 2024-08-15’, email@example.com);\n\n\nDelete from a table\nUse DELETE FROM\nDELETE FROM tablename \nWHERE condition;\n\n\nModify existing records within a table\nUse UPDATE\nUPDATE tablename \nSET columnname = value\nWHERE condition (if applicable);",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to SQL in Python</span>"
    ]
  },
  {
    "objectID": "sql.html#using-the-select-statement",
    "href": "sql.html#using-the-select-statement",
    "title": "Introduction to SQL in Python",
    "section": "Using the SELECT Statement",
    "text": "Using the SELECT Statement\nSELECT is used to select (retrieve) data from a database table.\nSELECT requires two pieces of information:\n\nWhat to SELECT\nWhere to SELECT it from\n\nSELECT column\nFROM table;\n\nRetrieve a Single Column\nSELECT prod_name\nFROM Products\n\n\nRetrieve Multiple Columns\nList columns in a comma delimited list\nSELECT prod_id, prod_name, prod_price\nFROM Products;\n\n\nRetrieve All Columns\nUse * to retrieve all columns from a table\nSELECT *\nFROM Products;\n\n\nRetrieve Distinct Rows\n\nAfter SELECT, use DISTINCT to select distinct values\n\nSELECT DISTINCT prod_name\nFROM Products\n\n\nLimit Retrieved Data\n\nUse LIMIT following the FROM statement to limit the amount of data retrieved\n\nSELECT prod_name\nFROM Products\nLIMIT 5;",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to SQL in Python</span>"
    ]
  },
  {
    "objectID": "sql.html#order-by",
    "href": "sql.html#order-by",
    "title": "Introduction to SQL in Python",
    "section": "ORDER BY",
    "text": "ORDER BY\nTo specify sort order, add ORDER BY to your SELECT statement.\nORDER BY requires one piece of information:\n\nThe column to sort by\nOptionally, you may also specify multiple sort columns as well as sort direction\n\nSELECT column\nFROM table\nORDER BY column ASC|DESC\n\nSort by One Column\nSELECT prod_name\nFROM Products\nORDER BY prod_name;\n\n\nSort by Multiple Columns\nSelect column names in a comma delimited list, and provide a list of columns to order by that are comma delimited.\nSELECT prod_id, prod_name, prod_price\nFROM Products\nORDER BY prod_price, prod_name;\n\n\nSpecify Sort Direction\nUse ASC or DESC\n\nThe default is ASC, however it is best practice to provide an explicit sort order\n\nSELECT prod_id, prod_name, prod_price\nFROM Products\nORDER BY prod_price, prod_name DESC;",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to SQL in Python</span>"
    ]
  },
  {
    "objectID": "sql.html#using-where",
    "href": "sql.html#using-where",
    "title": "Introduction to SQL in Python",
    "section": "Using WHERE",
    "text": "Using WHERE\nTo filter returned data, add WHERE to your SELECT statement\nWHERE requires one piece of information:\n\nThe filter condition (a statement that is tested against each row)\n\nGoes after FROM and before ORDER BY in the SELECT statement\nSELECT column\nFROM table\nWHERE condition\nORDER BY column ASC|DESC;\n\nWHERE Clause Operators:\n\nEquality: =\nNon-equality: != or &lt;&gt;\nLess than: &lt;\nLess than or equal to: &lt;=\nGreater than: &gt;\nGreater than or equal to: &gt;=\n\nExample:\nSELECT prod_name, prod_price\nFROM Products\nWHERE prod_price &lt; 10;\n\n\nFilter using a range using WHERE:\nUse WHERE column BETWEEN to filter using a range:\nSELECT prod_name, prod_price\nFROM Products\nWHERE prod_price BETWEEN 5 AND 10;\n\n\nFilter for No Value\nNull is a special keyword that means that a column has no value\n\nNULL is not the same as “”\n\nWHERE can be used with NULL to find (or exclude) columns with no value\nSELECT prod_name\nFROM Products\nWHERE prod_price IS NULL;\nThis will return only the rows that have a null value in a specified column",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to SQL in Python</span>"
    ]
  },
  {
    "objectID": "sql.html#combine-where-clauses",
    "href": "sql.html#combine-where-clauses",
    "title": "Introduction to SQL in Python",
    "section": "Combine WHERE clauses",
    "text": "Combine WHERE clauses\nWHERE clauses can be combined using\n\nAND (both conditions must be true)\nOR (one or more conditions must be true)\n\nSELECT prod_name, prod_price, prod_id\nFROM Products\nWHERE prod_id = 'DLL01'\nAND prod_price &lt;= 4;\n\nOrder of Evaluation\nAND always gets evaluated before OR in a where clause unless parentheses are used to explicitly change the order of evaluation.\nSELECT prod_name, prod_price\nFROM Products\nWHERE (prod_id = 'DLL01' OR prod_id = 'BRS01') AND prod_price &gt;= 10\nThe use of parentheses forces a higher level of evaluation.\nBest practice is to always use parentheses to explicitly control order of evaluation.\n\n\nFilter using IN\nIN is used to specify one or more values to be matched\nIN values are comma delimited\n\nIN (1,2,3)\n\nSELECT prod_name, prod_price\nFROM Products\nWHERE prod_id IN ('DLL01', 'BRS01') \nORDER BY prod_name; \nWhy use IN?:\n\nhelps to simplify order of evaluation\nuseful for filtering for multiple values\nuseful in subqueries\n\n\n\nNegate using NOT\nNOT is used to negate a WHERE clause NOT is inserted before the condition:\nSELECT prod_price\nFROM Products\nWHERE NOT prod_price = 3.49; \n\n\nFilter using LIKE\nUse LIKE to search using a wildcard\n\n% to match zero or more characters\n_ to match a single character\n\nSELECT prod_id, prod_name\nFROM Products\nWHERE prod_name LIKE 'F%';\nWill return matched text that begins with the letter F in the column prod_name. The % after the F indicates that any sequence of characters can follow.\nSELECT product_name\nFROM Products\nWHERE product_id LIKE '_A%';\nThis query would match ‘BA123’, ‘CA456’, etc.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to SQL in Python</span>"
    ]
  },
  {
    "objectID": "sql.html#creating-caclulated-fields",
    "href": "sql.html#creating-caclulated-fields",
    "title": "Introduction to SQL in Python",
    "section": "Creating Caclulated Fields",
    "text": "Creating Caclulated Fields\n\nUse Concatenation\nConcatenation is used to appends columns to each other.\n\nConcat()\n\nSELECT Concat(prod_name, ' (', prod_country, ')')\nFROM Products;\nThis query returns you prod_name (prod_country). For example, an output may be Teddy Bear (USA).\n\n\nUsing Aliases\nAliases are used to name database objects:\n\nTables\nColumns\nCalculated Fields\n\nTo create a column alias, you follow a column name or expression with either:\n\nan alias name -the AS keyword and an alias name\n\nSELECT Concat(prod_name, ' (', prod_country, ')') prod_title\nFROM Products;\nOR\nSELECT Concat(prod_name, ' (', prod_country, ')') AS prod_title\nFROM Products;\n\n\nPerform Mathematical Calculations\nSELECT statements can be used to perform mathematical calculations:\n\nAddition: +\nSubtraction: -\nMultiplication: *\nDivision: /\n\nWhen performing calculations, aliases can be used to name the results\nSELECT prod_id, quantity, item_price, quantity * item_price AS expanded_price\nFROM OrderItems\nWHERE order_num = 20008;\n\n\nUsing String Functions\nCommon functions include:\n\nLEFT() and RIGHT() to extract parts of a string\nLENGTH() to obtain the length of a string\nLOWER() and UPPER() to convert string case\nTRIM(), LTRIM(), and RTRIM to trim strings\n\nSELECT prod_name, UPPER(prod_name) AS prod_name_upcase\nFROM Products\nORDER BY prod_name;\nReturns to columns, prod_name and prod_name in all capital letters.\n\n\nUsing Date Functions\nDate functions are used to:\n\nExtract parts of dates and times\nCompare date and time values\nFormat dates and times for locale and language specific display\n\nSELECT order_num\nFROM orders\nWHERE YEAR(order_date) = 2012;\n\n\nUsing aggregate functions\nFrequently used Aggregate Functions are:\n\nAVG()\nCOUNT()\n\ncan be used with a column name or with *\n\nMAX()\nMIN()\nSUM()\n\nSELECT AVG(prod_price) AS avg_price, MIN(prod_price) AS price_min\nFROM Products;\nThis query returns the average prod_price and the minimum prod_price.\nSELECT COUNT(*) AS num_cust\nFROM Customers;\nThis query returns the total number of rows in the Customers table.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to SQL in Python</span>"
    ]
  },
  {
    "objectID": "sql.html#using-group-by",
    "href": "sql.html#using-group-by",
    "title": "Introduction to SQL in Python",
    "section": "Using GROUP BY",
    "text": "Using GROUP BY\nGROUP BY is used to summarize data by group\n\nA group is a unique column value\nGoes before ORDER BY and after WHERE\n\nSELECT column\nFROM table\nWHERE condition\nGROUP BY column\nORDER BY column ASC|DESC;\nSELECT vend_id, COUNT(*) AS num_prods\nFROM Products\nGROUP BY vend_id;",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to SQL in Python</span>"
    ]
  },
  {
    "objectID": "sql.html#using-having",
    "href": "sql.html#using-having",
    "title": "Introduction to SQL in Python",
    "section": "Using HAVING",
    "text": "Using HAVING\nHAVING is used to filter results at the group level\n\nHAVING is passed a filter statement, just like WHERE\nGoes after GROUP BY and before ORDER BY\n\nSELECT column\nFROM table\nWHERE condition\nGROUP BY column\nHAVING condition\nORDER BY column ASC|DESC;\n\nWHERE versus HAVING\n\nWHERE filters before data is grouped, and HAVING filters after data is grouped.\nRows that are eliminated by a WHERE clause will not be included in the group\n\nSELECT vend_id, COUNT(*) AS num_prods\nFROM Products\nWHERE prod_price &gt;= 4\nGROUP BY vend_id\nHAVING COUNT(*) &gt;= 2;",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to SQL in Python</span>"
    ]
  },
  {
    "objectID": "sql.html#using-subqueries-with-where",
    "href": "sql.html#using-subqueries-with-where",
    "title": "Introduction to SQL in Python",
    "section": "Using Subqueries with WHERE",
    "text": "Using Subqueries with WHERE\n\nA WHERE clause filters data retrieved by SELECT\nSubqueries allow the results of one query to be used as the filter conditions for another query\n\nSELECT cust_id\nFROM ORDERS\nWHERE order_num IN (SELECT order_num\n                    FROM OrderItems\n                    WHERE prod_id = 'RGAN01');\nThis query is selecting customer ID from orders where the order number is in whatever the results are from the subquery select statement.\n\nUsing Subqueries as Calculated Fields\nThis example, uses fully qualified table names to prevent ambiguity.\nSELECT cust_name, cust_state,\n      (SELECT COUNT(*) \n       FROM Orders\n       WHERE Orders.cust_id = Customers.cust_id) AS orders\nFROM Customers\nORDER BY cust_name;",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to SQL in Python</span>"
    ]
  },
  {
    "objectID": "sql.html#joining-tables",
    "href": "sql.html#joining-tables",
    "title": "Introduction to SQL in Python",
    "section": "Joining Tables",
    "text": "Joining Tables\n\nCreate a Basic Join\nTables are usually joined by keys\n\nA primary key uniquely identifies every row in a table -There can only ever be one of each primary key value\nA foreign key in a table contains the primary key value of a required table\n\nMultiple rows in table can have the same foreign key value\n\n\nThe Simplest join requires two tables that share a key which are tested for equality\n\nPrimary key in one table\nForeign key in another table\n\nThis is called an INNER JOIN\nSELECT vend_name, prod_name, prod_price\nFROM Vendors INNER JOIN Products \n  ON Vendors.vend_id = Products.vend_id;\n\n\nJoin Multiple Tables\nSELECT prod_name, vend_name, prod_price, quantity\nFROM OrderItems, Products, Vendors\nWHERE Products.vend_id = Vendors.vend_id\n  AND OrderItems.prod_id = Products.prod_id\n  AND order_num = 20007;",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to SQL in Python</span>"
    ]
  },
  {
    "objectID": "sql.html#creating-advanced-joins",
    "href": "sql.html#creating-advanced-joins",
    "title": "Introduction to SQL in Python",
    "section": "Creating Advanced Joins",
    "text": "Creating Advanced Joins\n\nUsing Table Aliases\nSimilar to how aliases are used to name or rename columns, aliases can also be used to rename tables\nSELECT column\nFROM table AS alias;\n\n\nCreating a Self Join\n\nA self join is used to join a table to itself.\nWhen using self joins aliases must be used to uniquely name each table instance\n\nSELECT c1.cust_id, c1.cust_name, c1.cust_contact\nFROM Customers AS c1, Customers AS c2\nWHERE c1.cust_name = c2.cust_name \n  AND c2.cust_contact = 'Jim Jones';\n\n\nCreating an Outer Join\n\nAn INNER JOIN joins two tables and only retrieves rows that have related rows in the other table.\nAn outer join makes it possible to retrieve all the rows from one table regardless of whether or not they have related rows in the other table.\n\nLEFT OUTER JOIN or RIGHT OUTER JOIN\n\n\nSELECT Customers.cust_id, Orders.order_num\nFROM Customers LEFT OUTER JOIN Orders \n  ON Customers.cust_id = Orders.cust_id;\nSELECT Customers.cust_id, Orders.order_num\nFROM Customers RIGHT OUTER JOIN Orders \n  ON Customers.cust_id = Orders.cust_id;",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to SQL in Python</span>"
    ]
  },
  {
    "objectID": "sql.html#combining-queries",
    "href": "sql.html#combining-queries",
    "title": "Introduction to SQL in Python",
    "section": "Combining Queries",
    "text": "Combining Queries\n\nUsing a UNION\nThe UNION operator combines the result sets of two or more SELECT statements into a single, distinct result set.\nTo use a UNION, orovide both complete queries with the keyword UNION between them\nSELECT cust_name, cust_contact, cust_email\nFROM Customers\nWHERE cust_state IN ('IL', 'IN', 'MI')\nUNION\nSELECT cust_name, cust_contact, cust_email\nFROM Customers\nWHERE cust_name = 'Fun4All';\nUNION rules:\n\nAll queries must have the same columns\nColumn order need not be the same\nColumn types need not be the same but must be compatible\n\n\n\nIncluding/Excluding Duplicates\n\nUnions automatically exclude duplicates\nTo include all rows, even duplicates, use UNION ALL\n\nSELECT cust_name, cust_contact, cust_email\nFROM Customers\nWHERE cust_state IN ('IL', 'IN', 'MI')\nUNION ALL\nSELECT cust_name, cust_contact, cust_email\nFROM Customers\nWHERE cust_name = 'Fun4All';\n\n\nSorting Combined Queries\nWhen using a UNION, only one ORDER BY may be used\nSELECT cust_name, cust_contact, cust_email\nFROM Customers\nWHERE cust_state IN ('IL', 'IN', 'MI')\nUNION ALL\nSELECT cust_name, cust_contact, cust_email\nFROM Customers\nWHERE cust_name = 'Fun4All'\nORDER BY cust_name, cust_contact;",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to SQL in Python</span>"
    ]
  },
  {
    "objectID": "sql.html#the-select-statement-revisited",
    "href": "sql.html#the-select-statement-revisited",
    "title": "Introduction to SQL in Python",
    "section": "The SELECT Statement Revisited",
    "text": "The SELECT Statement Revisited\nSELECT column\nFROM table(s)\n  ON join\nGROUP BY column\nHAVING condition\nUNION\nORDER BY column ASC|DESC;",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to SQL in Python</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "Summary",
    "section": "",
    "text": "In this online book, we went over information to make sure you had some basics to really start learning R. This journey began with the basics of R, emphasizing that while multiple methods exist to achieve the same results in R, it’s crucial to find the approach that works best for you. As we learn R, you will get used to doing things your way to be able to slice and evaluate the data to find rich information from the data sets we look at. As long as the data was handled properly, it does not matter how we reach our goal using R as long as we do it ourselves.\nMastering R allows you to effectively clean, analyze, and interpret data, unlocking valuable insights from various datasets. We explored the essential practice of data cleaning, learning various techniques and popular functions within the dplyr package under the tidyverse. Proper data cleaning ensures the integrity and accuracy of your analysis. We delved into skewness, kurtosis, variables, and scales of measurement, focusing on summarizing qualitative and quantitative data. Visualizations were introduced as powerful tools to describe variables and uncover patterns in the data.\nWe examined basic probability rules were covered alongside binomial and continuous distributions. We examined the normal distribution, its limitations, and methods for transforming non-normal variables. Central limit theorem is discussed with the Empirical rule alongside normal distributions.\n\nThis book has equipped you with the foundational skills needed to handle data before deeply analyzing it using R. Remember, the key to mastering these techniques lies in consistent practice and finding the methods that best suit your analytical style.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Summary</span>"
    ]
  }
]